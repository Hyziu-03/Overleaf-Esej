\newpage

\section{Programowanie proceduralne}

\subsection{Zalety podejścia proceduralnego}

\begin{flushleft}
    W tym paradygmacie każdy program składa się z procedur inaczej zwanych funkcjami. Każda z nich zawiera kilka kroków, które należy wykonać w momencie wywołania. \cite{procedural-definition} Powoduje to relatywną prostotę stworzenia danego programu. Początkujące osoby nie muszą się uczyć skomplikowanej struktury, aby móc zacząć pisać kod.
\end{flushleft}

\begin{flushleft}
    Uważam jednak, że na dłuższą metę nie można polegać na tej cesze. Im większy i bardziej obszerny program, tym więcej linii kodu pozostanie bez kontekstu w licznych funkcjach.
\end{flushleft}

\begin{mdframed}[backgroundcolor=yellow!20]
    Celem poprawienia czytelności kodu napisanego proceduralnie często jego fragmenty albo całe funkcje przenosi się do innych dedykowanych plików. W językach takich jak C wykorzystuje się do tego pliki nagłówkowe. \cite{procedural-header-files}
\end{mdframed}

\subsection{Kiedy programowanie proceduralne się nie sprawdzi?}

\begin{mdframed}[backgroundcolor=yellow!20]
    Zdecydowaną wadą programów pisanych proceduralnie jest ich mała \linebreak skalowalność. Z tego powodu nie jest to optymalne podejściu przy pisaniu dużych i skomplikowanych aplikacji z siatką zależności.
\end{mdframed}

\begin{flushleft}
    Pomimo banalności tego stwierdzenia - wadą programów proceduralnych jest brak funkcjonalności podejścia obiektowego. Sprawia to dużą trudność w reprezentacji obiektów ze świata i przeszkadza w utrzymywaniu kodu w dłuższej perspektywie. \cite{procedural-drawbacks}
\end{flushleft}

\begin{flushleft}
    Niestety w paradygmacie proceduralnym większy nacisk kładzie się na funkcje, aniżeli na dane, co może sprawiać trudności w budowaniu aplikacji. W późniejszej fazie rozwoju oprogramowania bardzo trudno jest zmienić architekturę i naprawić to, co zostało zrobione na początku.
\end{flushleft}
